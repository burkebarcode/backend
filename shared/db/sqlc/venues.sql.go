// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: venues.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createVenue = `-- name: CreateVenue :one
INSERT INTO venues (name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, user_id, is_public)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, created_at, updated_at, user_id, is_public
`

type CreateVenueParams struct {
	Name            string        `json:"name"`
	Description     string        `json:"description"`
	VenueType       string        `json:"venue_type"`
	Address         pgtype.Text   `json:"address"`
	City            pgtype.Text   `json:"city"`
	State           pgtype.Text   `json:"state"`
	Country         pgtype.Text   `json:"country"`
	Lat             pgtype.Float8 `json:"lat"`
	Lng             pgtype.Float8 `json:"lng"`
	HasBeer         pgtype.Int2   `json:"has_beer"`
	HasWine         pgtype.Int2   `json:"has_wine"`
	HasCocktails    pgtype.Int2   `json:"has_cocktails"`
	MapProvider     pgtype.Text   `json:"map_provider"`
	ExternalPlaceID pgtype.Text   `json:"external_place_id"`
	UserID          pgtype.UUID   `json:"user_id"`
	IsPublic        pgtype.Int2   `json:"is_public"`
}

func (q *Queries) CreateVenue(ctx context.Context, arg CreateVenueParams) (Venue, error) {
	row := q.db.QueryRow(ctx, createVenue,
		arg.Name,
		arg.Description,
		arg.VenueType,
		arg.Address,
		arg.City,
		arg.State,
		arg.Country,
		arg.Lat,
		arg.Lng,
		arg.HasBeer,
		arg.HasWine,
		arg.HasCocktails,
		arg.MapProvider,
		arg.ExternalPlaceID,
		arg.UserID,
		arg.IsPublic,
	)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.VenueType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Lat,
		&i.Lng,
		&i.HasBeer,
		&i.HasWine,
		&i.HasCocktails,
		&i.MapProvider,
		&i.ExternalPlaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.IsPublic,
	)
	return i, err
}

const getVenueByExternalPlaceID = `-- name: GetVenueByExternalPlaceID :one
SELECT id, name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, created_at, updated_at, user_id, is_public FROM venues WHERE external_place_id = $1 LIMIT 1
`

func (q *Queries) GetVenueByExternalPlaceID(ctx context.Context, externalPlaceID pgtype.Text) (Venue, error) {
	row := q.db.QueryRow(ctx, getVenueByExternalPlaceID, externalPlaceID)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.VenueType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Lat,
		&i.Lng,
		&i.HasBeer,
		&i.HasWine,
		&i.HasCocktails,
		&i.MapProvider,
		&i.ExternalPlaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.IsPublic,
	)
	return i, err
}

const getVenueByID = `-- name: GetVenueByID :one
SELECT id, name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, created_at, updated_at, user_id, is_public FROM venues WHERE id = $1
`

func (q *Queries) GetVenueByID(ctx context.Context, id pgtype.UUID) (Venue, error) {
	row := q.db.QueryRow(ctx, getVenueByID, id)
	var i Venue
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.VenueType,
		&i.Address,
		&i.City,
		&i.State,
		&i.Country,
		&i.Lat,
		&i.Lng,
		&i.HasBeer,
		&i.HasWine,
		&i.HasCocktails,
		&i.MapProvider,
		&i.ExternalPlaceID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserID,
		&i.IsPublic,
	)
	return i, err
}

const listVenues = `-- name: ListVenues :many
SELECT id, name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, created_at, updated_at, user_id, is_public FROM venues
WHERE is_public = 1 OR user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListVenuesParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) ListVenues(ctx context.Context, arg ListVenuesParams) ([]Venue, error) {
	rows, err := q.db.Query(ctx, listVenues, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Venue
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.VenueType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Lat,
			&i.Lng,
			&i.HasBeer,
			&i.HasWine,
			&i.HasCocktails,
			&i.MapProvider,
			&i.ExternalPlaceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchVenues = `-- name: SearchVenues :many
SELECT id, name, description, venue_type, address, city, state, country, lat, lng, has_beer, has_wine, has_cocktails, map_provider, external_place_id, created_at, updated_at, user_id, is_public FROM venues
WHERE (is_public = 1 OR user_id = $1)
  AND (name ILIKE '%' || $2 || '%'
   OR city ILIKE '%' || $2 || '%'
   OR address ILIKE '%' || $2 || '%')
ORDER BY created_at DESC
LIMIT $3
`

type SearchVenuesParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 pgtype.Text `json:"column_2"`
	Limit   int32       `json:"limit"`
}

func (q *Queries) SearchVenues(ctx context.Context, arg SearchVenuesParams) ([]Venue, error) {
	rows, err := q.db.Query(ctx, searchVenues, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Venue
	for rows.Next() {
		var i Venue
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.VenueType,
			&i.Address,
			&i.City,
			&i.State,
			&i.Country,
			&i.Lat,
			&i.Lng,
			&i.HasBeer,
			&i.HasWine,
			&i.HasCocktails,
			&i.MapProvider,
			&i.ExternalPlaceID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
