// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: recommendations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecommendationFeedback = `-- name: CreateRecommendationFeedback :one

INSERT INTO recommendation_feedback (user_id, beverage_id, feedback_type)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, beverage_id, feedback_type) DO NOTHING
RETURNING id, user_id, beverage_id, feedback_type, created_at
`

type CreateRecommendationFeedbackParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	BeverageID   pgtype.UUID `json:"beverage_id"`
	FeedbackType string      `json:"feedback_type"`
}

// Recommendation Feedback
func (q *Queries) CreateRecommendationFeedback(ctx context.Context, arg CreateRecommendationFeedbackParams) (RecommendationFeedback, error) {
	row := q.db.QueryRow(ctx, createRecommendationFeedback, arg.UserID, arg.BeverageID, arg.FeedbackType)
	var i RecommendationFeedback
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BeverageID,
		&i.FeedbackType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFeedback = `-- name: DeleteFeedback :exec
DELETE FROM recommendation_feedback
WHERE user_id = $1 AND beverage_id = $2 AND feedback_type = $3
`

type DeleteFeedbackParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	BeverageID   pgtype.UUID `json:"beverage_id"`
	FeedbackType string      `json:"feedback_type"`
}

func (q *Queries) DeleteFeedback(ctx context.Context, arg DeleteFeedbackParams) error {
	_, err := q.db.Exec(ctx, deleteFeedback, arg.UserID, arg.BeverageID, arg.FeedbackType)
	return err
}

const getBeverageWithTags = `-- name: GetBeverageWithTags :one
SELECT b.id, b.name, b.brand, b.category, b.vintage, b.image_url, b.name_normalized, b.brand_normalized, b.total_reviews, b.avg_rating, b.created_at, b.updated_at,
       COALESCE(
         json_agg(
           json_build_object(
             'tag', bta.tag,
             'tag_type', bta.tag_type,
             'count', bta.count
           )
         ) FILTER (WHERE bta.tag IS NOT NULL),
         '[]'::json
       ) AS tags_json
FROM beverages b
LEFT JOIN beverage_tag_aggregates bta ON b.id = bta.beverage_id
WHERE b.id = $1
GROUP BY b.id
`

type GetBeverageWithTagsRow struct {
	ID              pgtype.UUID        `json:"id"`
	Name            string             `json:"name"`
	Brand           pgtype.Text        `json:"brand"`
	Category        string             `json:"category"`
	Vintage         pgtype.Text        `json:"vintage"`
	ImageUrl        pgtype.Text        `json:"image_url"`
	NameNormalized  string             `json:"name_normalized"`
	BrandNormalized pgtype.Text        `json:"brand_normalized"`
	TotalReviews    pgtype.Int4        `json:"total_reviews"`
	AvgRating       pgtype.Numeric     `json:"avg_rating"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	TagsJson        interface{}        `json:"tags_json"`
}

func (q *Queries) GetBeverageWithTags(ctx context.Context, id pgtype.UUID) (GetBeverageWithTagsRow, error) {
	row := q.db.QueryRow(ctx, getBeverageWithTags, id)
	var i GetBeverageWithTagsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Brand,
		&i.Category,
		&i.Vintage,
		&i.ImageUrl,
		&i.NameNormalized,
		&i.BrandNormalized,
		&i.TotalReviews,
		&i.AvgRating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TagsJson,
	)
	return i, err
}

const getHiddenBeveragesForUser = `-- name: GetHiddenBeveragesForUser :many
SELECT beverage_id FROM recommendation_feedback
WHERE user_id = $1 AND feedback_type = 'hide'
`

func (q *Queries) GetHiddenBeveragesForUser(ctx context.Context, userID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getHiddenBeveragesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var beverage_id pgtype.UUID
		if err := rows.Scan(&beverage_id); err != nil {
			return nil, err
		}
		items = append(items, beverage_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecommendationCandidates = `-- name: GetRecommendationCandidates :many

SELECT b.id, b.name, b.brand, b.category, b.image_url, b.created_at, b.updated_at,
       COUNT(DISTINCT p.id) AS review_count,
       COALESCE(AVG(
         CASE
           WHEN p.score IS NOT NULL AND p.score != 0 THEN p.score
           WHEN p.stars IS NOT NULL THEN p.stars * 2.0
           ELSE NULL
         END
       ), 0) AS avg_rating
FROM beverages b
LEFT JOIN posts p ON b.id = p.beverage_id
WHERE b.category = $1
  AND b.id NOT IN (
    SELECT rf.beverage_id FROM recommendation_feedback rf
    WHERE rf.user_id = $2 AND rf.feedback_type = 'hide'
  )
  AND b.id NOT IN (
    SELECT p2.beverage_id FROM posts p2
    WHERE p2.user_id = $2 AND p2.beverage_id IS NOT NULL
    ORDER BY p2.created_at DESC
    LIMIT 20
  )
GROUP BY b.id, b.name, b.brand, b.category, b.image_url, b.created_at, b.updated_at
HAVING COUNT(DISTINCT p.id) >= 2 OR EXISTS (
  SELECT 1 FROM beverage_tag_aggregates bta
  WHERE bta.beverage_id = b.id
)
ORDER BY review_count DESC, avg_rating DESC
LIMIT $3
`

type GetRecommendationCandidatesParams struct {
	Category string      `json:"category"`
	UserID   pgtype.UUID `json:"user_id"`
	Limit    int32       `json:"limit"`
}

type GetRecommendationCandidatesRow struct {
	ID          pgtype.UUID        `json:"id"`
	Name        string             `json:"name"`
	Brand       pgtype.Text        `json:"brand"`
	Category    string             `json:"category"`
	ImageUrl    pgtype.Text        `json:"image_url"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	ReviewCount int64              `json:"review_count"`
	AvgRating   interface{}        `json:"avg_rating"`
}

// Recommendation Candidates
func (q *Queries) GetRecommendationCandidates(ctx context.Context, arg GetRecommendationCandidatesParams) ([]GetRecommendationCandidatesRow, error) {
	rows, err := q.db.Query(ctx, getRecommendationCandidates, arg.Category, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecommendationCandidatesRow
	for rows.Next() {
		var i GetRecommendationCandidatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Brand,
			&i.Category,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ReviewCount,
			&i.AvgRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEmbedding = `-- name: GetUserEmbedding :one

SELECT user_id, category, embedding_text, embedding_vector, model, updated_at FROM user_embeddings
WHERE user_id = $1 AND category = $2
`

type GetUserEmbeddingParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category string      `json:"category"`
}

// User Embeddings (optional)
func (q *Queries) GetUserEmbedding(ctx context.Context, arg GetUserEmbeddingParams) (UserEmbedding, error) {
	row := q.db.QueryRow(ctx, getUserEmbedding, arg.UserID, arg.Category)
	var i UserEmbedding
	err := row.Scan(
		&i.UserID,
		&i.Category,
		&i.EmbeddingText,
		&i.EmbeddingVector,
		&i.Model,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFeedback = `-- name: GetUserFeedback :many
SELECT id, user_id, beverage_id, feedback_type, created_at FROM recommendation_feedback
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserFeedback(ctx context.Context, userID pgtype.UUID) ([]RecommendationFeedback, error) {
	rows, err := q.db.Query(ctx, getUserFeedback, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecommendationFeedback
	for rows.Next() {
		var i RecommendationFeedback
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BeverageID,
			&i.FeedbackType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFeedbackForBeverage = `-- name: GetUserFeedbackForBeverage :many
SELECT id, user_id, beverage_id, feedback_type, created_at FROM recommendation_feedback
WHERE user_id = $1 AND beverage_id = $2
`

type GetUserFeedbackForBeverageParams struct {
	UserID     pgtype.UUID `json:"user_id"`
	BeverageID pgtype.UUID `json:"beverage_id"`
}

func (q *Queries) GetUserFeedbackForBeverage(ctx context.Context, arg GetUserFeedbackForBeverageParams) ([]RecommendationFeedback, error) {
	rows, err := q.db.Query(ctx, getUserFeedbackForBeverage, arg.UserID, arg.BeverageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecommendationFeedback
	for rows.Next() {
		var i RecommendationFeedback
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BeverageID,
			&i.FeedbackType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPostCountByCategory = `-- name: GetUserPostCountByCategory :one
SELECT COUNT(*) AS count
FROM posts
WHERE user_id = $1 AND drink_category = $2
`

type GetUserPostCountByCategoryParams struct {
	UserID        pgtype.UUID `json:"user_id"`
	DrinkCategory string      `json:"drink_category"`
}

func (q *Queries) GetUserPostCountByCategory(ctx context.Context, arg GetUserPostCountByCategoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUserPostCountByCategory, arg.UserID, arg.DrinkCategory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserPostsForCategory = `-- name: GetUserPostsForCategory :many
SELECT p.id, p.user_id, p.venue_id, p.drink_name, p.drink_category, p.stars, p.notes, p.wine_post_details_id, p.beer_post_details_id, p.cocktail_post_details_id, p.price_cents, p.photo_url, p.created_at, p.updated_at, p.score, p.beverage_id, pt.tag, pt.tag_type, pt.confidence
FROM posts p
LEFT JOIN post_tags pt ON p.id = pt.post_id
WHERE p.user_id = $1
  AND p.drink_category = $2
ORDER BY p.created_at DESC
`

type GetUserPostsForCategoryParams struct {
	UserID        pgtype.UUID `json:"user_id"`
	DrinkCategory string      `json:"drink_category"`
}

type GetUserPostsForCategoryRow struct {
	ID                    pgtype.UUID        `json:"id"`
	UserID                pgtype.UUID        `json:"user_id"`
	VenueID               pgtype.UUID        `json:"venue_id"`
	DrinkName             string             `json:"drink_name"`
	DrinkCategory         string             `json:"drink_category"`
	Stars                 pgtype.Int4        `json:"stars"`
	Notes                 pgtype.Text        `json:"notes"`
	WinePostDetailsID     pgtype.UUID        `json:"wine_post_details_id"`
	BeerPostDetailsID     pgtype.UUID        `json:"beer_post_details_id"`
	CocktailPostDetailsID pgtype.UUID        `json:"cocktail_post_details_id"`
	PriceCents            pgtype.Int4        `json:"price_cents"`
	PhotoUrl              pgtype.Text        `json:"photo_url"`
	CreatedAt             pgtype.Timestamptz `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz `json:"updated_at"`
	Score                 pgtype.Numeric     `json:"score"`
	BeverageID            pgtype.UUID        `json:"beverage_id"`
	Tag                   pgtype.Text        `json:"tag"`
	TagType               pgtype.Text        `json:"tag_type"`
	Confidence            pgtype.Numeric     `json:"confidence"`
}

func (q *Queries) GetUserPostsForCategory(ctx context.Context, arg GetUserPostsForCategoryParams) ([]GetUserPostsForCategoryRow, error) {
	rows, err := q.db.Query(ctx, getUserPostsForCategory, arg.UserID, arg.DrinkCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPostsForCategoryRow
	for rows.Next() {
		var i GetUserPostsForCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VenueID,
			&i.DrinkName,
			&i.DrinkCategory,
			&i.Stars,
			&i.Notes,
			&i.WinePostDetailsID,
			&i.BeerPostDetailsID,
			&i.CocktailPostDetailsID,
			&i.PriceCents,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Score,
			&i.BeverageID,
			&i.Tag,
			&i.TagType,
			&i.Confidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTasteProfile = `-- name: GetUserTasteProfile :one

SELECT user_id, category, liked_tags_json, disliked_tags_json, mean_rating, std_rating, post_count, last_computed_at, updated_at FROM user_taste_profiles
WHERE user_id = $1 AND category = $2
`

type GetUserTasteProfileParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category string      `json:"category"`
}

// User Taste Profiles
func (q *Queries) GetUserTasteProfile(ctx context.Context, arg GetUserTasteProfileParams) (UserTasteProfile, error) {
	row := q.db.QueryRow(ctx, getUserTasteProfile, arg.UserID, arg.Category)
	var i UserTasteProfile
	err := row.Scan(
		&i.UserID,
		&i.Category,
		&i.LikedTagsJson,
		&i.DislikedTagsJson,
		&i.MeanRating,
		&i.StdRating,
		&i.PostCount,
		&i.LastComputedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserEmbedding = `-- name: UpsertUserEmbedding :one
INSERT INTO user_embeddings (user_id, category, embedding_text, embedding_vector, model)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (user_id, category)
DO UPDATE SET
  embedding_text = EXCLUDED.embedding_text,
  embedding_vector = EXCLUDED.embedding_vector,
  model = EXCLUDED.model
RETURNING user_id, category, embedding_text, embedding_vector, model, updated_at
`

type UpsertUserEmbeddingParams struct {
	UserID          pgtype.UUID `json:"user_id"`
	Category        string      `json:"category"`
	EmbeddingText   string      `json:"embedding_text"`
	EmbeddingVector []float32   `json:"embedding_vector"`
	Model           pgtype.Text `json:"model"`
}

func (q *Queries) UpsertUserEmbedding(ctx context.Context, arg UpsertUserEmbeddingParams) (UserEmbedding, error) {
	row := q.db.QueryRow(ctx, upsertUserEmbedding,
		arg.UserID,
		arg.Category,
		arg.EmbeddingText,
		arg.EmbeddingVector,
		arg.Model,
	)
	var i UserEmbedding
	err := row.Scan(
		&i.UserID,
		&i.Category,
		&i.EmbeddingText,
		&i.EmbeddingVector,
		&i.Model,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertUserTasteProfile = `-- name: UpsertUserTasteProfile :one
INSERT INTO user_taste_profiles (
  user_id, category, liked_tags_json, disliked_tags_json,
  mean_rating, std_rating, post_count, last_computed_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, now())
ON CONFLICT (user_id, category)
DO UPDATE SET
  liked_tags_json = EXCLUDED.liked_tags_json,
  disliked_tags_json = EXCLUDED.disliked_tags_json,
  mean_rating = EXCLUDED.mean_rating,
  std_rating = EXCLUDED.std_rating,
  post_count = EXCLUDED.post_count,
  last_computed_at = EXCLUDED.last_computed_at
RETURNING user_id, category, liked_tags_json, disliked_tags_json, mean_rating, std_rating, post_count, last_computed_at, updated_at
`

type UpsertUserTasteProfileParams struct {
	UserID           pgtype.UUID    `json:"user_id"`
	Category         string         `json:"category"`
	LikedTagsJson    []byte         `json:"liked_tags_json"`
	DislikedTagsJson []byte         `json:"disliked_tags_json"`
	MeanRating       pgtype.Numeric `json:"mean_rating"`
	StdRating        pgtype.Numeric `json:"std_rating"`
	PostCount        pgtype.Int4    `json:"post_count"`
}

func (q *Queries) UpsertUserTasteProfile(ctx context.Context, arg UpsertUserTasteProfileParams) (UserTasteProfile, error) {
	row := q.db.QueryRow(ctx, upsertUserTasteProfile,
		arg.UserID,
		arg.Category,
		arg.LikedTagsJson,
		arg.DislikedTagsJson,
		arg.MeanRating,
		arg.StdRating,
		arg.PostCount,
	)
	var i UserTasteProfile
	err := row.Scan(
		&i.UserID,
		&i.Category,
		&i.LikedTagsJson,
		&i.DislikedTagsJson,
		&i.MeanRating,
		&i.StdRating,
		&i.PostCount,
		&i.LastComputedAt,
		&i.UpdatedAt,
	)
	return i, err
}
