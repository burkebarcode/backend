// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: ai_summaries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createOpenAIJob = `-- name: CreateOpenAIJob :one
INSERT INTO openai_jobs (job_type, beverage_id, post_id, status)
VALUES ($1, $2, $3, 'queued')
RETURNING id, job_type, beverage_id, post_id, status, attempts, last_error, created_at, updated_at
`

type CreateOpenAIJobParams struct {
	JobType    string      `json:"job_type"`
	BeverageID pgtype.UUID `json:"beverage_id"`
	PostID     pgtype.UUID `json:"post_id"`
}

func (q *Queries) CreateOpenAIJob(ctx context.Context, arg CreateOpenAIJobParams) (OpenaiJob, error) {
	row := q.db.QueryRow(ctx, createOpenAIJob, arg.JobType, arg.BeverageID, arg.PostID)
	var i OpenaiJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.BeverageID,
		&i.PostID,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPostTag = `-- name: CreatePostTag :one
INSERT INTO post_tags (post_id, beverage_id, tag, tag_type, confidence)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, post_id, beverage_id, tag, tag_type, confidence, created_at
`

type CreatePostTagParams struct {
	PostID     pgtype.UUID    `json:"post_id"`
	BeverageID pgtype.UUID    `json:"beverage_id"`
	Tag        string         `json:"tag"`
	TagType    string         `json:"tag_type"`
	Confidence pgtype.Numeric `json:"confidence"`
}

func (q *Queries) CreatePostTag(ctx context.Context, arg CreatePostTagParams) (PostTag, error) {
	row := q.db.QueryRow(ctx, createPostTag,
		arg.PostID,
		arg.BeverageID,
		arg.Tag,
		arg.TagType,
		arg.Confidence,
	)
	var i PostTag
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.BeverageID,
		&i.Tag,
		&i.TagType,
		&i.Confidence,
		&i.CreatedAt,
	)
	return i, err
}

const deleteBeverageSummary = `-- name: DeleteBeverageSummary :exec
DELETE FROM beverage_summaries WHERE beverage_id = $1
`

func (q *Queries) DeleteBeverageSummary(ctx context.Context, beverageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeverageSummary, beverageID)
	return err
}

const deleteBeverageTagAggregates = `-- name: DeleteBeverageTagAggregates :exec
DELETE FROM beverage_tag_aggregates WHERE beverage_id = $1
`

func (q *Queries) DeleteBeverageTagAggregates(ctx context.Context, beverageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeverageTagAggregates, beverageID)
	return err
}

const deleteOpenAIJob = `-- name: DeleteOpenAIJob :exec
DELETE FROM openai_jobs WHERE id = $1
`

func (q *Queries) DeleteOpenAIJob(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOpenAIJob, id)
	return err
}

const deletePostTags = `-- name: DeletePostTags :exec
DELETE FROM post_tags WHERE post_id = $1
`

func (q *Queries) DeletePostTags(ctx context.Context, postID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePostTags, postID)
	return err
}

const getBeverageSummary = `-- name: GetBeverageSummary :one
SELECT beverage_id, summary_text, descriptors_json, pros_json, cons_json, coverage_score, source_review_count, model, model_version, generated_at, updated_at FROM beverage_summaries WHERE beverage_id = $1
`

func (q *Queries) GetBeverageSummary(ctx context.Context, beverageID pgtype.UUID) (BeverageSummary, error) {
	row := q.db.QueryRow(ctx, getBeverageSummary, beverageID)
	var i BeverageSummary
	err := row.Scan(
		&i.BeverageID,
		&i.SummaryText,
		&i.DescriptorsJson,
		&i.ProsJson,
		&i.ConsJson,
		&i.CoverageScore,
		&i.SourceReviewCount,
		&i.Model,
		&i.ModelVersion,
		&i.GeneratedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBeverageTagAggregates = `-- name: GetBeverageTagAggregates :many
SELECT beverage_id, tag, tag_type, count, updated_at FROM beverage_tag_aggregates
WHERE beverage_id = $1
ORDER BY count DESC, tag
`

func (q *Queries) GetBeverageTagAggregates(ctx context.Context, beverageID pgtype.UUID) ([]BeverageTagAggregate, error) {
	rows, err := q.db.Query(ctx, getBeverageTagAggregates, beverageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BeverageTagAggregate
	for rows.Next() {
		var i BeverageTagAggregate
		if err := rows.Scan(
			&i.BeverageID,
			&i.Tag,
			&i.TagType,
			&i.Count,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeverageTags = `-- name: GetBeverageTags :many
SELECT tag, tag_type, COUNT(*) as count
FROM post_tags
WHERE beverage_id = $1
GROUP BY tag, tag_type
ORDER BY count DESC, tag
`

type GetBeverageTagsRow struct {
	Tag     string `json:"tag"`
	TagType string `json:"tag_type"`
	Count   int64  `json:"count"`
}

func (q *Queries) GetBeverageTags(ctx context.Context, beverageID pgtype.UUID) ([]GetBeverageTagsRow, error) {
	rows, err := q.db.Query(ctx, getBeverageTags, beverageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBeverageTagsRow
	for rows.Next() {
		var i GetBeverageTagsRow
		if err := rows.Scan(&i.Tag, &i.TagType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOpenAIJob = `-- name: GetOpenAIJob :one
SELECT id, job_type, beverage_id, post_id, status, attempts, last_error, created_at, updated_at FROM openai_jobs WHERE id = $1
`

func (q *Queries) GetOpenAIJob(ctx context.Context, id pgtype.UUID) (OpenaiJob, error) {
	row := q.db.QueryRow(ctx, getOpenAIJob, id)
	var i OpenaiJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.BeverageID,
		&i.PostID,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingSummaryJob = `-- name: GetPendingSummaryJob :one
SELECT id, job_type, beverage_id, post_id, status, attempts, last_error, created_at, updated_at FROM openai_jobs
WHERE job_type = 'summary' AND beverage_id = $1 AND status IN ('queued', 'running')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetPendingSummaryJob(ctx context.Context, beverageID pgtype.UUID) (OpenaiJob, error) {
	row := q.db.QueryRow(ctx, getPendingSummaryJob, beverageID)
	var i OpenaiJob
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.BeverageID,
		&i.PostID,
		&i.Status,
		&i.Attempts,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostTags = `-- name: GetPostTags :many
SELECT id, post_id, beverage_id, tag, tag_type, confidence, created_at FROM post_tags WHERE post_id = $1
`

func (q *Queries) GetPostTags(ctx context.Context, postID pgtype.UUID) ([]PostTag, error) {
	rows, err := q.db.Query(ctx, getPostTags, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostTag
	for rows.Next() {
		var i PostTag
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.BeverageID,
			&i.Tag,
			&i.TagType,
			&i.Confidence,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueuedJobs = `-- name: GetQueuedJobs :many
SELECT id, job_type, beverage_id, post_id, status, attempts, last_error, created_at, updated_at FROM openai_jobs
WHERE status = 'queued'
ORDER BY created_at
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetQueuedJobs(ctx context.Context, limit int32) ([]OpenaiJob, error) {
	rows, err := q.db.Query(ctx, getQueuedJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OpenaiJob
	for rows.Next() {
		var i OpenaiJob
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.BeverageID,
			&i.PostID,
			&i.Status,
			&i.Attempts,
			&i.LastError,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOpenAIJobStatus = `-- name: UpdateOpenAIJobStatus :exec
UPDATE openai_jobs
SET status = $2, attempts = $3, last_error = $4, updated_at = NOW()
WHERE id = $1
`

type UpdateOpenAIJobStatusParams struct {
	ID        pgtype.UUID `json:"id"`
	Status    string      `json:"status"`
	Attempts  pgtype.Int4 `json:"attempts"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) UpdateOpenAIJobStatus(ctx context.Context, arg UpdateOpenAIJobStatusParams) error {
	_, err := q.db.Exec(ctx, updateOpenAIJobStatus,
		arg.ID,
		arg.Status,
		arg.Attempts,
		arg.LastError,
	)
	return err
}

const upsertBeverageSummary = `-- name: UpsertBeverageSummary :one
INSERT INTO beverage_summaries (
  beverage_id, summary_text, descriptors_json, pros_json, cons_json,
  coverage_score, source_review_count, model, model_version
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (beverage_id)
DO UPDATE SET
  summary_text = EXCLUDED.summary_text,
  descriptors_json = EXCLUDED.descriptors_json,
  pros_json = EXCLUDED.pros_json,
  cons_json = EXCLUDED.cons_json,
  coverage_score = EXCLUDED.coverage_score,
  source_review_count = EXCLUDED.source_review_count,
  model = EXCLUDED.model,
  model_version = EXCLUDED.model_version,
  generated_at = NOW(),
  updated_at = NOW()
RETURNING beverage_id, summary_text, descriptors_json, pros_json, cons_json, coverage_score, source_review_count, model, model_version, generated_at, updated_at
`

type UpsertBeverageSummaryParams struct {
	BeverageID        pgtype.UUID    `json:"beverage_id"`
	SummaryText       string         `json:"summary_text"`
	DescriptorsJson   []byte         `json:"descriptors_json"`
	ProsJson          []byte         `json:"pros_json"`
	ConsJson          []byte         `json:"cons_json"`
	CoverageScore     pgtype.Numeric `json:"coverage_score"`
	SourceReviewCount pgtype.Int4    `json:"source_review_count"`
	Model             pgtype.Text    `json:"model"`
	ModelVersion      pgtype.Text    `json:"model_version"`
}

func (q *Queries) UpsertBeverageSummary(ctx context.Context, arg UpsertBeverageSummaryParams) (BeverageSummary, error) {
	row := q.db.QueryRow(ctx, upsertBeverageSummary,
		arg.BeverageID,
		arg.SummaryText,
		arg.DescriptorsJson,
		arg.ProsJson,
		arg.ConsJson,
		arg.CoverageScore,
		arg.SourceReviewCount,
		arg.Model,
		arg.ModelVersion,
	)
	var i BeverageSummary
	err := row.Scan(
		&i.BeverageID,
		&i.SummaryText,
		&i.DescriptorsJson,
		&i.ProsJson,
		&i.ConsJson,
		&i.CoverageScore,
		&i.SourceReviewCount,
		&i.Model,
		&i.ModelVersion,
		&i.GeneratedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertBeverageTagAggregate = `-- name: UpsertBeverageTagAggregate :exec
INSERT INTO beverage_tag_aggregates (beverage_id, tag, tag_type, count)
VALUES ($1, $2, $3, $4)
ON CONFLICT (beverage_id, tag, tag_type)
DO UPDATE SET
  count = EXCLUDED.count,
  updated_at = NOW()
`

type UpsertBeverageTagAggregateParams struct {
	BeverageID pgtype.UUID `json:"beverage_id"`
	Tag        string      `json:"tag"`
	TagType    string      `json:"tag_type"`
	Count      int32       `json:"count"`
}

func (q *Queries) UpsertBeverageTagAggregate(ctx context.Context, arg UpsertBeverageTagAggregateParams) error {
	_, err := q.db.Exec(ctx, upsertBeverageTagAggregate,
		arg.BeverageID,
		arg.Tag,
		arg.TagType,
		arg.Count,
	)
	return err
}
