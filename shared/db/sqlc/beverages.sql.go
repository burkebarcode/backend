// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: beverages.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBeverage = `-- name: CreateBeverage :one
INSERT INTO beverages (name, brand, category, vintage, image_url, name_normalized, brand_normalized)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, name, brand, category, vintage, image_url, name_normalized, brand_normalized, total_reviews, avg_rating, created_at, updated_at
`

type CreateBeverageParams struct {
	Name            string      `json:"name"`
	Brand           pgtype.Text `json:"brand"`
	Category        string      `json:"category"`
	Vintage         pgtype.Text `json:"vintage"`
	ImageUrl        pgtype.Text `json:"image_url"`
	NameNormalized  string      `json:"name_normalized"`
	BrandNormalized pgtype.Text `json:"brand_normalized"`
}

func (q *Queries) CreateBeverage(ctx context.Context, arg CreateBeverageParams) (Beverage, error) {
	row := q.db.QueryRow(ctx, createBeverage,
		arg.Name,
		arg.Brand,
		arg.Category,
		arg.Vintage,
		arg.ImageUrl,
		arg.NameNormalized,
		arg.BrandNormalized,
	)
	var i Beverage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Brand,
		&i.Category,
		&i.Vintage,
		&i.ImageUrl,
		&i.NameNormalized,
		&i.BrandNormalized,
		&i.TotalReviews,
		&i.AvgRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBeverageByID = `-- name: GetBeverageByID :one
SELECT id, name, brand, category, vintage, image_url, name_normalized, brand_normalized, total_reviews, avg_rating, created_at, updated_at FROM beverages WHERE id = $1
`

func (q *Queries) GetBeverageByID(ctx context.Context, id pgtype.UUID) (Beverage, error) {
	row := q.db.QueryRow(ctx, getBeverageByID, id)
	var i Beverage
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Brand,
		&i.Category,
		&i.Vintage,
		&i.ImageUrl,
		&i.NameNormalized,
		&i.BrandNormalized,
		&i.TotalReviews,
		&i.AvgRating,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPostsForBeverage = `-- name: GetPostsForBeverage :many
SELECT p.id, p.user_id, p.venue_id, p.drink_name, p.drink_category, p.stars, p.notes, p.wine_post_details_id, p.beer_post_details_id, p.cocktail_post_details_id, p.price_cents, p.photo_url, p.created_at, p.updated_at, p.score, p.beverage_id FROM posts p
WHERE
  (p.drink_name = $1 OR LOWER(p.drink_name) = $2) AND
  ($3::TEXT IS NULL OR p.drink_category = $3)
ORDER BY p.created_at DESC
LIMIT $4
`

type GetPostsForBeverageParams struct {
	DrinkName   string `json:"drink_name"`
	DrinkName_2 string `json:"drink_name_2"`
	Column3     string `json:"column_3"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) GetPostsForBeverage(ctx context.Context, arg GetPostsForBeverageParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPostsForBeverage,
		arg.DrinkName,
		arg.DrinkName_2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VenueID,
			&i.DrinkName,
			&i.DrinkCategory,
			&i.Stars,
			&i.Notes,
			&i.WinePostDetailsID,
			&i.BeerPostDetailsID,
			&i.CocktailPostDetailsID,
			&i.PriceCents,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Score,
			&i.BeverageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopReviewsForBeverage = `-- name: GetTopReviewsForBeverage :many
SELECT p.id, p.user_id, p.venue_id, p.drink_name, p.drink_category, p.stars, p.notes, p.wine_post_details_id, p.beer_post_details_id, p.cocktail_post_details_id, p.price_cents, p.photo_url, p.created_at, p.updated_at, p.score, p.beverage_id FROM posts p
WHERE
  (p.drink_name = $1 OR LOWER(p.drink_name) = $2) AND
  ($3::TEXT IS NULL OR p.drink_category = $3) AND
  p.score IS NOT NULL
ORDER BY p.score DESC, p.created_at DESC
LIMIT $4
`

type GetTopReviewsForBeverageParams struct {
	DrinkName   string `json:"drink_name"`
	DrinkName_2 string `json:"drink_name_2"`
	Column3     string `json:"column_3"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) GetTopReviewsForBeverage(ctx context.Context, arg GetTopReviewsForBeverageParams) ([]Post, error) {
	rows, err := q.db.Query(ctx, getTopReviewsForBeverage,
		arg.DrinkName,
		arg.DrinkName_2,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.VenueID,
			&i.DrinkName,
			&i.DrinkCategory,
			&i.Stars,
			&i.Notes,
			&i.WinePostDetailsID,
			&i.BeerPostDetailsID,
			&i.CocktailPostDetailsID,
			&i.PriceCents,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Score,
			&i.BeverageID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchBeveragesByTokens = `-- name: SearchBeveragesByTokens :many
SELECT
  b.id, b.name, b.brand, b.category, b.vintage, b.image_url, b.name_normalized, b.brand_normalized, b.total_reviews, b.avg_rating, b.created_at, b.updated_at,
  -- Calculate match score
  (
    -- Exact name match (highest priority)
    CASE WHEN b.name_normalized = $1 THEN 100 ELSE 0 END +
    -- Name prefix match
    CASE WHEN b.name_normalized LIKE $1 || '%' THEN 50 ELSE 0 END +
    -- Name contains match
    CASE WHEN b.name_normalized LIKE '%' || $1 || '%' THEN 25 ELSE 0 END +
    -- Brand exact match
    CASE WHEN b.brand_normalized = $2 THEN 80 ELSE 0 END +
    -- Brand prefix match
    CASE WHEN b.brand_normalized LIKE $2 || '%' THEN 40 ELSE 0 END +
    -- Brand contains match
    CASE WHEN b.brand_normalized LIKE '%' || $2 || '%' THEN 20 ELSE 0 END +
    -- Vintage exact match bonus
    CASE WHEN $3::TEXT IS NOT NULL AND b.vintage = $3::TEXT THEN 30 ELSE 0 END +
    -- Category match bonus
    CASE WHEN b.category = $4 THEN 10 ELSE 0 END
  ) as match_score
FROM beverages b
WHERE
  (
    b.name_normalized LIKE '%' || $1 || '%' OR
    b.brand_normalized LIKE '%' || $2 || '%' OR
    ($3::TEXT IS NOT NULL AND b.vintage = $3::TEXT)
  )
ORDER BY match_score DESC, b.avg_rating DESC
LIMIT $5
`

type SearchBeveragesByTokensParams struct {
	NameNormalized  string      `json:"name_normalized"`
	BrandNormalized pgtype.Text `json:"brand_normalized"`
	Column3         string      `json:"column_3"`
	Category        string      `json:"category"`
	Limit           int32       `json:"limit"`
}

type SearchBeveragesByTokensRow struct {
	ID              pgtype.UUID        `json:"id"`
	Name            string             `json:"name"`
	Brand           pgtype.Text        `json:"brand"`
	Category        string             `json:"category"`
	Vintage         pgtype.Text        `json:"vintage"`
	ImageUrl        pgtype.Text        `json:"image_url"`
	NameNormalized  string             `json:"name_normalized"`
	BrandNormalized pgtype.Text        `json:"brand_normalized"`
	TotalReviews    pgtype.Int4        `json:"total_reviews"`
	AvgRating       pgtype.Numeric     `json:"avg_rating"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	MatchScore      int32              `json:"match_score"`
}

func (q *Queries) SearchBeveragesByTokens(ctx context.Context, arg SearchBeveragesByTokensParams) ([]SearchBeveragesByTokensRow, error) {
	rows, err := q.db.Query(ctx, searchBeveragesByTokens,
		arg.NameNormalized,
		arg.BrandNormalized,
		arg.Column3,
		arg.Category,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchBeveragesByTokensRow
	for rows.Next() {
		var i SearchBeveragesByTokensRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Brand,
			&i.Category,
			&i.Vintage,
			&i.ImageUrl,
			&i.NameNormalized,
			&i.BrandNormalized,
			&i.TotalReviews,
			&i.AvgRating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MatchScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBeverageStats = `-- name: UpdateBeverageStats :exec
UPDATE beverages
SET
  total_reviews = $2,
  avg_rating = $3,
  updated_at = NOW()
WHERE id = $1
`

type UpdateBeverageStatsParams struct {
	ID           pgtype.UUID    `json:"id"`
	TotalReviews pgtype.Int4    `json:"total_reviews"`
	AvgRating    pgtype.Numeric `json:"avg_rating"`
}

func (q *Queries) UpdateBeverageStats(ctx context.Context, arg UpdateBeverageStatsParams) error {
	_, err := q.db.Exec(ctx, updateBeverageStats, arg.ID, arg.TotalReviews, arg.AvgRating)
	return err
}
